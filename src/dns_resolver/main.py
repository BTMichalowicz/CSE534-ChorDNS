# -*- generated by 1.0.12 -*-
import da
_config_object = {}
import bisect
import hashlib
import random
import os
node_client = da.import_da('client')
node_chord = da.import_da('chord')

def read_input_file(filename):
    datas = []
    input_file = open(filename, 'r')
    for line in input_file:
        datas.append(tuple(line.strip().split(' ')))
    return datas

def hash_func(name, m):
    hash = int(hashlib.sha1(name.encode('utf-8')).hexdigest(), 16)
    hash_val = (hash % (2 ** m))
    return hash_val

def build_setup_args(idx, m, node_tuples, hashed_nodes_keys, hashed_datas, hashed_datas_keys):
    setup_args = {}
    setup_args['pred_node'] = node_tuples[(idx - 1)]
    setup_args['succ_node'] = node_tuples[((idx + 1) % len(hashed_nodes_keys))]
    setup_args['finger_table'] = build_finger_table(idx, m, node_tuples, hashed_nodes_keys)
    setup_args['node_datas'] = assign_datas_to_node(idx, hashed_datas, hashed_datas_keys, hashed_nodes_keys)
    return setup_args

def build_finger_table(idx, m, node_tuples, hashed_nodes_keys):
    hash_val = hashed_nodes_keys[idx]
    finger_table = []
    for i in range(0, m):
        finger_idx = bisect.bisect_left(hashed_nodes_keys, ((hash_val + (2 ** i)) % (2 ** m)))
        finger_table.append(node_tuples[(finger_idx % len(node_tuples))])
    return finger_table

def assign_datas_to_node(idx, hashed_datas, hashed_datas_keys, hashed_nodes_keys):
    limit_s = hashed_nodes_keys[(idx - 1)]
    limit_e = hashed_nodes_keys[idx]
    start = bisect.bisect_left(hashed_datas_keys, limit_s)
    end = bisect.bisect(hashed_datas_keys, limit_e)
    if (limit_s == hashed_datas_keys[start]):
        start += 1
    datas = {}
    if (limit_s <= limit_e):
        for i in range(start, end):
            hash_val = hashed_datas_keys[i]
            datas[hash_val] = hashed_datas[hash_val]
    else:
        for i in range(start, len(hashed_datas_keys)):
            hash_val = hashed_datas_keys[i]
            datas[hash_val] = hashed_datas[hash_val]
        for i in range(0, end):
            hash_val = hashed_datas_keys[i]
            datas[hash_val] = hashed_datas[hash_val]
    return datas

def take_input():
    website = input('Enter website name: ')
    return [website]

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])
    _config_object = {'channel': {'reliable', 'fifo'}}

    def run(self):
        datas = read_input_file('data/dns_records.txt')
        m = 20
        hash_vals = []
        repeats = []
        for i in datas:
            hash_val = hash_func(i[0], m)
            if (not (hash_val in hash_vals)):
                hash_vals.append(hash_val)
            else:
                repeats.append((hash_val, i))
        self.output('Total collison by the hash function: ', len(repeats))
        hashed_datas = {hash_func(data[0], m): data for data in datas}
        hashed_datas_keys = list(hashed_datas.keys())
        hashed_datas_keys.sort()
        nodes = ['1.2.3.5', '2.3.4.5', '11.22.33.55', '8.8.8.9', '2.22.1.2', '77.66.3.1', '1.2.3.6', '2.3.4.6', '11.22.33.56', '8.8.8.10', '2.22.1.3', '77.66.3.2', '1.2.3.7', '2.3.4.7', '11.22.33.57', '8.8.8.11', '2.22.1.4', '77.66.3.3', '1.2.3.8', '2.3.4.8', '11.22.33.58', '8.8.8.12', '2.22.1.5', '77.66.3.4', '1.2.3.9', '2.3.4.9', '11.22.33.59', '8.8.8.13', '2.22.1.6', '77.66.3.5']
        hashed_nodes = {hash_func(node, m): node for node in nodes}
        hashed_nodes_keys = list(hashed_nodes.keys())
        hashed_nodes_keys.sort()
        self.output('Hash values for all the nodes in sorted order: ', hashed_nodes_keys)
        chord_processes = list(self.new(node_chord.Chord, num=len(hashed_nodes_keys)))
        node_tuples = []
        for i in range(0, len(hashed_nodes_keys)):
            node_tuples.append((hashed_nodes_keys[i], chord_processes[i], nodes[i]))
        for i in range(0, len(hashed_nodes_keys)):
            setup_args = build_setup_args(i, m, node_tuples, hashed_nodes_keys, hashed_datas, hashed_datas_keys)
            self._setup(chord_processes[i], args=(node_tuples[i], m, setup_args['pred_node'], setup_args['succ_node'], setup_args['finger_table'], setup_args['node_datas']))
        self._start(chord_processes)
        website = take_input()
        client_process = self.new(node_client.Client)
        self._setup(client_process, args=(client_process, m, node_tuples, website))
        self._start(client_process)
        super()._label('_st_label_732', block=False)
        _st_label_732 = 0
        while (_st_label_732 == 0):
            _st_label_732 += 1
            if False:
                _st_label_732 += 1
            else:
                super()._label('_st_label_732', block=True)
                _st_label_732 -= 1
