# -*- generated by 1.0.12 -*-
import da
_config_object = {}
import bisect
import hashlib
import random
import os
class_Resolver = da.import_da('resolver_dev')
class_Node = da.import_da('node_dev')

def hash_func(name, m):
    hash = int(hashlib.sha1(name.encode('utf-8')).hexdigest(), 16)
    hash_val = (hash % (2 ** m))
    return hash_val

def assign_datas_to_node(idx, hashed_datas_keys, hashed_nodes_keys, hashed_datas):
    lo_id = hashed_nodes_keys[(idx - 1)]
    hi_id = hashed_nodes_keys[idx]
    lo = bisect.bisect_left(hashed_datas_keys, lo_id)
    if (hashed_nodes_keys[(idx - 1)] == hashed_datas_keys[lo]):
        lo += 1
    datas = {}
    if (lo_id <= hi_id):
        i = lo
        while (hashed_datas_keys[i] <= hi_id):
            hash_val = hashed_datas_keys[i]
            datas[hash_val] = hashed_datas[hash_val]
            i += 1
    else:
        for i in range(lo, len(hashed_datas_keys)):
            hash_val = hashed_datas_keys[i]
            datas[hash_val] = hashed_datas[hash_val]
        i = 0
        while (hashed_datas_keys[i] <= hi_id):
            hash_val = hashed_datas_keys[i]
            datas[hash_val] = hashed_datas[hash_val]
            i += 1
    return datas

def build_finger_table(idx, m, hashed_nodes_keys, node_tuples):
    hash_val = hashed_nodes_keys[idx]
    finger_table = []
    for i in range(0, m):
        finger_idx = bisect.bisect_left(hashed_nodes_keys, ((hash_val + (2 ** i)) % (2 ** m)))
        finger_table.append(node_tuples[(finger_idx % len(node_tuples))])
    return finger_table

def read_input_file(filename):
    datas = []
    input_file = open(filename, 'r')
    for line in input_file:
        datas.append(tuple(line.strip().split(' ')))
    return datas

def take_input():
    website = input('Enter website name: ')
    return [website]

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])
    _config_object = {'channel': {'reliable', 'fifo'}}

    def run(self):
        datas = read_input_file('data/dns_records.txt')
        m = 20
        hash_vals = []
        repeats = []
        for i in datas:
            hash_val = hash_func(i[0], m)
            if (not (hash_val in hash_vals)):
                hash_vals.append(hash_val)
            else:
                repeats.append((hash_val, i))
        self.output('Total collison by the hash function: ', len(repeats))
        hashed_datas = {hash_func(data[0], m): data for data in datas}
        hashed_datas_keys = list(hashed_datas.keys())
        hashed_datas_keys.sort()
        nodes = ['1.2.3.5', '2.3.4.5', '11.22.33.55', '8.8.8.9', '2.22.1.2', '77.66.3.1', '1.2.3.6', '2.3.4.6', '11.22.33.56', '8.8.8.10', '2.22.1.3', '77.66.3.2', '1.2.3.7', '2.3.4.7', '11.22.33.57', '8.8.8.11', '2.22.1.4', '77.66.3.3', '1.2.3.8', '2.3.4.8', '11.22.33.58', '8.8.8.12', '2.22.1.5', '77.66.3.4', '1.2.3.9', '2.3.4.9', '11.22.33.59', '8.8.8.13', '2.22.1.6', '77.66.3.5']
        hashed_nodes = {hash_func(node, m): node for node in nodes}
        hashed_nodes_keys = list(hashed_nodes.keys())
        hashed_nodes_keys.sort()
        self.output('Hash values for all the nodes in sorted order: ', hashed_nodes_keys)
        node_processes = list(self.new(class_Node.Node, num=len(hashed_nodes_keys)))
        node_tuples = []
        for i in range(0, len(hashed_nodes_keys)):
            node_tuples.append((hashed_nodes_keys[i], node_processes[i], nodes[i]))
        for i in range(0, len(hashed_nodes_keys)):
            pred_node = node_tuples[(i - 1)]
            succ_node = node_tuples[((i + 1) % len(hashed_nodes_keys))]
            finger_table = build_finger_table(i, m, hashed_nodes_keys, node_tuples)
            self.output('Dheeraj ::: Finger table for node: ', node_tuples[i], ' is: ', finger_table)
            node_datas = assign_datas_to_node(i, hashed_datas_keys, hashed_nodes_keys, hashed_datas)
            self._setup(node_processes[i], args=(node_tuples[i], m, pred_node, succ_node, finger_table, node_datas))
        self._start(node_processes)
        website = take_input()
        resolver_process = self.new(class_Resolver.Resolver)
        self._setup(resolver_process, args=(resolver_process, m, node_tuples, website))
        self._start(resolver_process)
        super()._label('_st_label_705', block=False)
        _st_label_705 = 0
        while (_st_label_705 == 0):
            _st_label_705 += 1
            if False:
                _st_label_705 += 1
            else:
                super()._label('_st_label_705', block=True)
                _st_label_705 -= 1
